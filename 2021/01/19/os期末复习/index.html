<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OS期末复习 | Step by Step</title><meta name="keywords" content="Course,OS"><meta name="author" content="bebinca"><meta name="copyright" content="bebinca"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="OS复习 期末复习前的知识整理，个人使用。 01 Introduction   OS是资源分配者，是控制程序。总是在运行的程序指kernel。   bootstrap program：在power-up或者reboot的时候加载，是固件。初始化系统，load kernel开始执行。   CPU和device controller通过bus连到shared memory；竞争memory cycle">
<meta property="og:type" content="article">
<meta property="og:title" content="OS期末复习">
<meta property="og:url" content="https://bebinca.github.io/2021/01/19/os%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Step by Step">
<meta property="og:description" content="OS复习 期末复习前的知识整理，个人使用。 01 Introduction   OS是资源分配者，是控制程序。总是在运行的程序指kernel。   bootstrap program：在power-up或者reboot的时候加载，是固件。初始化系统，load kernel开始执行。   CPU和device controller通过bus连到shared memory；竞争memory cycle">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bebinca.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2021-01-19T02:11:00.000Z">
<meta property="article:modified_time" content="2021-10-08T08:10:00.808Z">
<meta property="article:author" content="bebinca">
<meta property="article:tag" content="Course">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bebinca.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://bebinca.github.io/2021/01/19/os%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d08fd87ab794bd5f35c672a549616661";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-08 16:10:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/08/yuiq3Oo8QIDLEpc.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Step by Step</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-01-19T02:11:00.000Z" title="Created 2021-01-19 10:11:00">2021-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-10-08T08:10:00.808Z" title="Updated 2021-10-08 16:10:00">2021-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Course/">Course</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>34min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>OS复习</h1>
<p>期末复习前的知识整理，个人使用。</p>
<h2 id="01-Introduction">01 Introduction</h2>
<ul>
<li>
<p>OS是资源分配者，是控制程序。总是在运行的程序指kernel。</p>
</li>
<li>
<p>bootstrap program：在power-up或者reboot的时候加载，是固件。初始化系统，load kernel开始执行。</p>
</li>
<li>
<p>CPU和device controller通过bus连到shared memory；竞争memory cycle</p>
</li>
<li>
<p>IO可以和CPU并发执行，每个device controller有一个local buffer。CPU通过buffer和memory互传数据；IO的数据从device到buffer。device controller通过interrupt通知CPU它完成了操作。</p>
</li>
<li>
<p>interrupt通过interrupt vector传输到相应的interrupt服务程序（service routine）。interrupt vector含有所有服务程序的地址。当别的interrupt正在处理的时候，incoming interrupts会被disabled。Interrupt architecture must save the address of the interrupted instruction. Incoming interrupts are *<strong>disabled*</strong> while another interrupt is being processed to prevent a <em>lost interrupt</em>.</p>
</li>
<li>
<p>trap是由error或user request引起的（system call）软件interrupt。</p>
</li>
<li>
<p>操作系统的运行是一种中断驱动机制。</p>
</li>
<li>
<p>CPU通过存储regsiter和program counter（指向要执行的指令地址）来保存状态；interrupt来源有轮询（polling，看看有没有interrupt）或者vectored interrupt system（设备自己通知有interrupt），可以以此推断interrupt类型；每种interrupt应该怎么处理的代码是分开的code片段。</p>
</li>
<li>
<p>IO有<strong>同步IO和异步IO。</strong></p>
<ul>
<li>同步IO：IO开始之后，等到IO完成，控制才会返回到用户程序；wait inst会idle掉CPU，直到下一个interrupt；同一时间最多有一个IO激活，不会有很多IO同步运行。</li>
</ul>
</li>
<li>
<p>异步IO：不需要等到IO完成，控制就返回用户程序，不用等待。System call给OS请求，允许user等待IO完成；device-status table存储了每个IO device的type，addr，state；OS intexes into这个table确定设备状态，修改以包括interrupt。</p>
</li>
<li>
<p>DMA：direct memory access。给高速IO设备使用，以memory速度传输数据；从buffer直接传输到主存，不需要CPU参与。每个block一个interrupt而不是每byte一个。</p>
</li>
<li>
<p>存储结构：主存，CPU能直接访问的；二级存储，提供非易失容量；磁盘。</p>
</li>
<li>
<p>Multitasking：recent value使用要谨慎；</p>
<p>Multiprocessor：提供cache coherence，使得所有的CPU都有recent value在cache里</p>
</li>
<li>
<p>Multiprogramming: 不让CPU空闲，每次载入一组process一起做，提高<strong>CPU利用率</strong>，比如有一个IO要wait的时候就切换到另一个。</p>
<p>Timesharing（multitasking）：是Multiprogramming的自然延申，CPU快速切换任务，用户的<strong>交互</strong>更好。每一个process都会给user回复。</p>
</li>
<li>
<p>Dual-mode：OS保护模式；User mode，kernel mode（mode bit区分）。user mode到kernel mode：call system call -&gt;trap, mode bit = 0 -&gt; execute system call -&gt; return, mode bit = 1 -&gt; return from system call。</p>
</li>
<li>
<p>VM</p>
</li>
<li>
<p>SYSTEM BOOT</p>
</li>
</ul>
<h2 id="02-os-structures">02 os structures</h2>
<ul>
<li>
<p>System calls：OS提供的服务接口，用户的调用一般是通过更高层面的API</p>
<ul>
<li>system call number；存有一个table</li>
<li>类型：process control，file manage，device manage，info maintenance，communication</li>
</ul>
</li>
<li>
<p>OS design：separate policy from mechanism</p>
</li>
<li>
<p><strong>Monolithic structure:</strong> everything is done in kernel!：UNIX</p>
<p><strong>Microkernel System Structure:</strong> 尽量把kernel的移到user的空间。好处：比较稳定。坏处：performance overhead比较大。</p>
<p><strong>Solaris Modular Approach:</strong> 彼此调用的时候不需要message passing，所以会比microkernel性能更好。</p>
</li>
</ul>
<h2 id="03-Processes">03 Processes</h2>
<ul>
<li>
<p>进程：program in execution。包括text section（code），program counter，stack（函数参数，local vars，return addr），data section（全局变量），heap（动态分配内存）</p>
</li>
<li>
<p>进程状态：new，running，waiting，ready，terminated</p>
</li>
<li>
<p>PCB：进程状态，PC，CPU reg content，CPU调度信息（优先级，指向调度队列的指针），memory管理信息（比如指向mem开始和结束的指针），accounting信息，IO状态信息。</p>
</li>
<li>
<p>进程调度队列：Job queue（可以找到所有的process），Ready queue（ready 状态的process，相当于CPU的device queue），device queues。进程在queue之间的转换由kernel控制。</p>
</li>
<li>
<p>scheduler：a piece of process。long-term：选出加载到内存的，现在一般不需要了。short-term：选出在CPU跑的process。</p>
<p>medium term scheduler：当内存挤不下那么多process。借助一个磁盘设备存储进程。这个地方称为swapped-out area.</p>
</li>
<li>
<p>process可以分成IO bound的和CPU bound的。</p>
</li>
<li>
<p>Context Switch: 保存旧的进程信息，载入新的；时间比较短，一般是milliseconds。加速：Register Ring，每个扇形一组reg，被一个process所使用。context switch的时候，只要把指针指到另一个reg组就可以了。</p>
</li>
<li>
<p>Process Creation: UNIX为例，fork()创建新进程，exec()把mem space替换成一个新的program，执行一个新的程序。调用folk之后，child会复制parent的内存映像，<strong>parent得到的return value是child的id；child得到的return value是0</strong>。所以可以通过这个value判断是parent process还是child process.</p>
</li>
<li>
<p>Process Termination：exit() ask the OS to delete it. 非正常退出abort：父进程终止掉子进程，或者用abort信号。如果parent terminate，child可能会全部terminate，也有可能被赋给init process(1)，此时这个进程被称为孤儿进程。给parent加一个wait，就会等待child进行完毕之后再退出。</p>
</li>
<li>
<p>Cooperating Process: 可以影响其他进程的执行，或者被影响。有利于信息共享，计算加速（多CPU）等。</p>
</li>
<li>
<p>Producer-Consumer Problem：</p>
<ul>
<li>
<p><strong>unbounded-buffer:</strong> the buffer space is not limited. <strong>producer</strong>不需要等待，<strong>consumer</strong>需要等待数据。</p>
<p><strong>bounded-buffer:</strong> fixed buffer size. 两个可能都需要等待。</p>
</li>
<li>
<p>shared mem solution：in == out是空的，in+1（要取模）==out是满的。个buffer space当成一个ring来用，利用一个in指针和out指针。避免size只有size-1的话，加一个counter记一下现在有多少个就好了。但是counter是共享变量，会带来很多麻烦。后面会讨论。</p>
</li>
</ul>
</li>
<li>
<p>IPC（Interprocess Communication）：Two models for IPC: <strong>message passing</strong> and <strong>shared memory</strong>。IPC提供send和receive两种操作，如果要在P和Q之间communicate，首先建立communication link，然后使用send/receive。link的实现有physical的（比如共享memory，bus），也有逻辑性的。</p>
<ul>
<li>Shared Memory不需要经过kernel（建立shared memory的时候还是需要的），更加高效，但也需要更加小心。</li>
<li>direct communication：直接通讯，需要严格指明是谁，send(P, message)指明目标, receive(Q, message)指明从谁发过来。</li>
<li>Indirect communication: 通过mailboxes (port)进行进程之间的间接通讯。只有在两个进程共享同一个mailbox的时候才能建立link。每个mailbox有唯一的ID。间接通讯不需要指定过程的ID，每个link可以给很多进程用，比直接通讯更加常用。send(A, message) and receive(A, message).</li>
</ul>
</li>
<li>
<p>Message passing有阻塞的和非阻塞的。阻塞的是同步的：Blocking send的sender被block起来，直到信息被收到；Blocking receive的receiver被block起来，直到信息可用。<u>非阻塞是异步的，发出去就发出去了，receive也不管是不是available。</u></p>
</li>
</ul>
<h2 id="04-Threads">04 Threads</h2>
<ul>
<li>
<p>同一进程的不同线程之间共享code，data，files，但动态分配的reg和stack不同。</p>
</li>
<li>
<p>多线程有利于实现交互、资源共享，相比建立进程更节约资源，（多核时）提高了并行能力。</p>
</li>
<li>
<p>User Threads: thread libraries. lib支持，如果用的是旧系统，kernel没有多线程，可以用library在上层提供多线程（POSIX Pthread，Win32 thread，Java thread）。Kernel Threads: kernel已经提供了多线程（几乎现在所有的OS都有）。</p>
</li>
<li>
<p>Multithreading models:</p>
<ul>
<li>Many to one：本质上没有用到kernel thread（不需要到kernel mode，也不用系统参与），所以一个“kernel thread”对应多个user thread。<strong>好处</strong>是线程管理更高效，不需要系统参与。<strong>缺点</strong>是如果有一个线程做了system call的话，整个进程就block掉了；同时对于多核OS来说它不能并行运行。对kernel来说，它的多线程是不可见的，一次block会block掉整个process而不是单个的线程，相当于在retrive data被block的时候，display等等其他功能都会一并block。</li>
<li>one to one：每一个user thread对应一个kernel thread。<strong>好处</strong>是并行解决了，也不会在某个线程做system call的时候，整个进程都block掉，唯一的<strong>坏处</strong>就是每创建一个user thread都需要一个kernel thread。</li>
<li>many to many, to level, …</li>
</ul>
</li>
<li>
<p>fork()的实现有的会dup所有的线程，有的只dup一个；exec()会替换整个进程，调用之后，原来的进程空间就不存在了。</p>
</li>
<li>
<p>Thread Cancellation（线程完成之前终止）。分为Asynchronous终止（立即终止）may be cancelled in the middle of updating data shared with other threads，may not free a system-wide resource  和Deferred中止（周期性通过flag检查是否需要终止）。at so called cancellation points in Pthread</p>
</li>
<li>
<p>UNIX用signal来通知一个进程特殊事件的发生。有一个signal handler。信号发给哪些线程取决于信号类型。</p>
</li>
<li>
<p>Thread pool：如果存在短时间内创建很多个thread的需求：在server启动的时候先创建好大量的thread，存在一个pool(array)里面。当有需求的时候，从pool里面拿一个空闲的，用完释放，这样就不会影响后面响应请求的速度（否则就需要不停的createThread）avoid creation and termination overhead, so that it is faster to service a request；put bound on number of threads, thus limit CPU and memory usage</p>
</li>
<li>
<p>linux里面，把线程叫tasks。通过clone()创建。允许子task和父task（process）共享地址空间。</p>
</li>
<li>
<p>同步信号和异步信号？<strong>synchronous signals -</strong> 1. an illegal memory access, a division by zero 2. delivered to the same process that cause the signal</p>
<p><strong>asynchronous signals</strong></p>
<ol>
<li>
<p>a user keystroke (Ctrl-C), a timer expiration</p>
</li>
<li>
<p>typically sent to another process</p>
</li>
</ol>
</li>
</ul>
<h2 id="05-CPU-Scheduling">05 CPU Scheduling</h2>
<ul>
<li>
<p>通过multiprogramming提高CPU利用率。</p>
</li>
<li>
<p>调整CPU burst &amp; I/O  burst: 一个CPU一个I/O；每个CPU burst末尾有一个I/O operation。</p>
</li>
<li>
<p>CPU scheduler会从ready queue上面选择一个进程，给它分配CPU。这里的是<strong>short time scheduler</strong>。</p>
</li>
<li>
<p>CPU scheduler可能会发生在：</p>
<ul>
<li>从running state到waiting state（比如遇到I/O）</li>
<li>从running state到ready state（interrupt）</li>
<li>从waiting state到ready state（I/O完成了，等等）</li>
<li>terminate</li>
<li>有的系统只做第1个和第4个，称为nonpreemptive（非抢占式OS）。只有process主动释放出来才会执行schedule，所以如果有一个程序一直在占用资源，就会一直占用着。</li>
<li>interrupt就是进入ready state。比如timer可以在某个程序跑太久的时候给它执行interrupt。</li>
</ul>
</li>
<li>
<p>Dispatcher: 把CPU控制给scheduler选定的进程。其实是<strong>context switch</strong>的过程。Dispatch latency: Dispatcher 在停止一个进程并开始另一个的花费时间</p>
<ul>
<li>switching context</li>
<li>switch to user mode</li>
<li>jump to proper location in user program to restart the program</li>
</ul>
</li>
<li>
<p>Scheduling Criteria调度指标：</p>
<ul>
<li>CPU utilization (CPU 利用率)，我们希望它尽可能高。</li>
<li>Throughput (吞吐率) 单位时间完成进程的个数。</li>
<li>Turnaround time (周转时间) ，执行时间，即提交任务到任务完成的时间。</li>
<li>Waiting time (等待时间) 在ready queue里的时间，不是waiting state的时间。</li>
<li>Response time (响应时间) submit request到第一次有response的时间。</li>
</ul>
</li>
<li>
<p>优化指标：增大CPU利用率和吞吐率，减少各项时间</p>
</li>
<li>
<p>调度算法：画gantt chart，计算waiting time和awt。</p>
<ul>
<li>
<p>FCFS；FIFO?</p>
</li>
<li>
<p>SJF：短的先去。有非抢占式和非抢占式两种。抢占式：如果来了一个时间比当前剩下时间少的，就换。理论最优，问题在于，我们无法知道下一个CPU Burst的length。有一个平均的算法。</p>
</li>
<li>
<p>Priority：根据Priority Number来判断，先做Priority最高的进程（small integer =&gt; highest priority）同样有非抢占式和非抢占式两种。Problem：Starvation，低优先级可能一直不会被执行。Solution：Aging，随着时间提高优先级</p>
</li>
<li>
<p>RR round robin：每个进程都有一小段CPU time (time quantum)。假定ready queue里面有n个进程，假定time quantum有q time unit，那么没有进程的waiting time超过 (n-1)q.</p>
</li>
<li>
<p>multilevel queue：ready queue拆开，foreground - interactive. 用RR策略。background - batch.  用FCFS策略。time slice。</p>
</li>
<li>
<p>multilevel feedback queue：进程可以移动到别的queue。例子：有三个queue：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - RR with time quantum = 8 ms</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - RR with time quantum = 16ms</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Q_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - FCFS</p>
<p>对于一个进程，首先进入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如果还没有执行完，进入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，如果还没有结束进入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Q_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这个算法是比较合理的，我们可以设想到，一个CPU burst比较长的进程，一般也不需要太好的交互性。</p>
</li>
</ul>
</li>
<li>
<p>多处理器调度：</p>
<ul>
<li>非对称多处理：有一个processor负责管理system data structure，负责调度，别的processor只做执行任务</li>
<li>对称多处理（SMP）：每个Processor自己解决调度问题。比较常见</li>
</ul>
</li>
<li>
<p>Real-Time Scheduling：能够保证一个task可以在real time指定时间内完成。</p>
<ul>
<li>Hard real-time systems: 在指定的时间里必须完成。</li>
<li>Soft real-time computing: 把priority给这些没完成的。</li>
</ul>
</li>
<li>
<p>Thread Scheduling:</p>
<ul>
<li>Local Scheduling: thread library (user mode) decides。many to one只能做这个。</li>
<li>Global Scheduling: kernel decides, 会把管理的线程一起排。</li>
</ul>
</li>
</ul>
<h2 id="06-Process-Synchronization">06 Process Synchronization</h2>
<ul>
<li>Process Synchronization: Concurrent access to shared data may result in data inconsistency. 保证数据的一致性需要保证按照正确顺序来执行进程。</li>
<li>producer-consumer problem: 我们有一个空间是用不到的。所以可以添加一个计数器记录item数量，这样可以利用buffer内的所有空间。这个计数器是共享变量，可能造成race condition，count++实际上是一个三条汇编指令构成的过程，也就有可能被interrupt。于是就有可能出现类似count++和count–的指令交织的过程。</li>
<li>critical section：entry section - <strong>critical section</strong> - exit section - remainder section</li>
<li>解决需要满足：
<ul>
<li><strong>Mutual Exclusion</strong>: 互斥性。如果有一个process在critical section里执行，则其他processes都不能在它们的critical sections里执行。</li>
<li><strong>Progress</strong>. 如果没有process在critical section，但是已经有process请求进入，那一定要执行对进入critical section的progress的选择。</li>
<li><strong>Bounded Waiting</strong>. 如果有process请求进入critical section，那它等待其他process进去的次数得是有上界的。假设每个process执行的速度非0，对系统里的N个process，我们没有对其相对速度的假设。</li>
</ul>
</li>
<li>Peterson’s solution：2进程solution，假定LOAD和STORE指令是原子性的，不能被interrupted。<strong>share 2 var:</strong> int turn（轮到谁进CS）, boolean flag[2]（表示一个进程想进CS）。bound=1</li>
<li>Synchronization Hardware：对于单处理器的OS来说，可以在entry section，disable interrupt；在exit section，enable interrupt。但这样是相对低效的，对多处理器来说就更糟了。所以提供了一些原子的硬件指令（test and set，swap……）。这些指令不能被打断。
<ul>
<li>TestAndSet Instruction: set true and return val</li>
<li>Swap Instruction: swap the 2 values</li>
</ul>
</li>
<li>Semaphore: Semaphore S是一个integer变量。wait()或signal()可以修改S的值。这两个操作是原子性的，不能被打断。wait: 等到S为正的时候执行decrement。signal: 执行increment。</li>
<li>Counting semaphore: 没有限制范围。</li>
<li>binary semaphore: S只能取0或1。也被称为mutex locks。</li>
<li>有一个问题：wait()里面的while过程是busy waiting，这是我们不希望的，这些指令应该都是atomic的。而且我们要保证没有进程的wait()和signal()不能同时执行，它本身就是一个critical section的内容。</li>
<li>without busy waiting：重新实现wait和signal。对于每个Semaphore，相应的有一个waiting queue。提供两个操作：block（把process放到waiting queue；wakeup：把一个process从wait queue放到ready queue）。
<ul>
<li>wait：value–，如果小于0，block</li>
<li>signal：value++，如果小于等于0，wakeup一个进程。</li>
</ul>
</li>
<li>deadlock：互相等。</li>
<li>starvation：一直被block。</li>
<li>monitor：Only one process may be active within the monitor at a time；the other processes may be sleeping within the monitor；high-level abstraction</li>
</ul>
<h2 id="07-Deadlocks">07 Deadlocks</h2>
<ul>
<li>
<p>各自享有一定资源的blocked进程，等待获得对方的资源。（waiting for each other）</p>
</li>
<li>
<p>System model：Resource type: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>R</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R_1, \dots, R_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>; 每种有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个实例。</p>
<p>Protocol: request - use - release</p>
</li>
<li>
<p>Deadlock Characterization，死锁条件：</p>
<ul>
<li><strong>Mutual exclusion:</strong> 该资源同一时间仅有一个进程可以使用。e.g. single-core CPU, a byte in Memory, printer.</li>
<li><strong>Hold &amp; wait:</strong> 进程自己拥有一定资源，并且在等待获得其他进程的资源。</li>
<li><strong>No preemption:</strong> 无法抢占其他进程的资源，只能享有者自行放弃。</li>
<li><strong>Circular wait:</strong> 存在成环等待链。</li>
</ul>
</li>
<li>
<p>死锁预防</p>
<ul>
<li>
<p>对于request for resource做出一定限制。</p>
<ul>
<li>Hold &amp; Wait: 资源只能在进程启动之前分配，或者在进程没有资源的时候分配。（但是效率太低了）</li>
<li>No Preemption: 允许Preemption? mmm</li>
<li><strong>Circular Wait:</strong> 给 Resource type 编号，每个进程从小到大发出request。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>死锁避免</p>
<ul>
<li>
<p>需要系统预先知道一些信息。（priori information）：进程最多使用多少种 Resource Type；动态检测算法，保证不会有deadlock；Resource-allocation state</p>
</li>
<li>
<p>系统处于<strong>safe state</strong>：存在一个包含所有进程的序列，每个进程只需要请求它前面的进程的资源或当前可用的资源。<strong>按照这个序列进程可以顺利执行完毕。</strong></p>
<ul>
<li>safe state -&gt; no deadlock</li>
<li>unsafe state -&gt; possibility of deadlock</li>
<li>avoidance: 保证系统永远不会处于unsafe的状态。</li>
</ul>
</li>
<li>
<p>分配算法：</p>
<ul>
<li>
<p>Single instance: 用图</p>
<ul>
<li>Claim edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>→</mo><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_i \rightarrow R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> : 以后可能会请求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。（虚线）</li>
<li>Request edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>→</mo><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_i \rightarrow R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>：确实请求了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。（实线）</li>
<li>Assignment edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub><mo>→</mo><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_j \rightarrow P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> : 现在有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。（实线）</li>
</ul>
<p>这个图如果出现了环路，就不太安全，要防止某个虚线变成实线然后成环。所以可以在分配的时候（request =&gt; assignment）防止成环，拒绝对应的request。</p>
</li>
<li>
<p>Multiple instance: <strong>Banker’s Algorithm</strong></p>
<ul>
<li>
<p>前提：Multiple instances;  每个进程事先声明最多用多少；request资源之后，进程可能需要等待；进程得到所有它需要的资源之后必须有限时间内释放。</p>
</li>
<li>
<p>必要的数据结构：<strong>n个进程，m种资源</strong>。</p>
<ul>
<li><code>Avaliable[]</code> of length <code>m</code>. <code>Available[j] = k</code>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个可用instance。</li>
<li><code>Max</code> of <code>n * m</code>.  <code>Max[i][j] = k</code>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 最多申请 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 类型的资源。</li>
<li><code>Allocation</code> of <code>n * m</code>.  <code>Allocation[i][j] = k</code>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 已经被分配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 类型的资源。</li>
<li><code>Need</code> of <code>n * m</code>.  <code>Max[i][j] = k</code>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 还需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 类型的资源才能完成。</li>
<li><code>Need[i][j] = Max[i][j] - Allocation[i][j]</code>。</li>
</ul>
</li>
<li>
<p><strong>Safety Algorithm:</strong> 找到上面safe state说到的安全序列。第一层算法。</p>
<p><strong>Work</strong> of length m（表示资源可用的数量，init available）, <strong>Finish</strong> of length n（表示进程是否可以完成，init false）</p>
<ol>
<li>找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 满足 Finish[i] = false, Need[i] &lt;= Work。如果不存在，去第三步。</li>
<li>Work = Work + Allocation[i]，Finish[i] = true. 去第一步。</li>
<li>如果对所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> ，Finish[i] = true，那么系统处于安全状态。</li>
</ol>
</li>
<li>
<p><strong>Resource-Request Algorithm:</strong> 第二层算法。</p>
<p><code>Request[i][j] = k</code>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>想要k个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<ol>
<li>
<p>如果Request[i] &lt;= Need[i]，去下一步。否则报错。（合法性检查）</p>
</li>
<li>
<p>如果Request[i] &lt;= Available[i]，说明当前可满足，去下一步。否则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 需要等待，因为资源尚未满足。</p>
</li>
<li>
<p>假定现在把资源分配给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 了，修改状态如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Available = Available - Request;</span><br><span class="line">Allocation[i] = Allocation[i] + Request[i];</span><br><span class="line">Need[i] = Need[i] - Request[i];</span><br></pre></td></tr></table></figure>
<p>调用safety algorithm，检查新的状态是否安全。如果安全，就把资源分配给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；否则，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 还是要等待，状态恢复到原样。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>死锁检测：允许系统进入死锁状态，通过算法检测死锁，并建立Recovery scheme。</p>
<ul>
<li>
<p>Single instance: <strong>wait-for graph</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><mo>&gt;</mo><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_i =&gt; P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在等 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">P_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<ul>
<li>周期性调用找环路的算法，找到了就说明有死锁。</li>
<li>找环算法复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 是顶点数。</li>
</ul>
</li>
<li>
<p>Multiple instance: 类似Banker algorithm。</p>
<p>仍然有Available，Allocation向量，Request向量表示现在在向系统请求多少资源。</p>
<ol>
<li>找到一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 满足 Finish[i] = false，Request[i] &lt;= Work。找不到去第三步。</li>
<li>Work = Work + Allocation[i], Finish[i] = true。去第一步。</li>
<li>如果存在某个Finish[i]还是false，说明系统在死锁状态，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>被锁住了。</li>
</ol>
<p><strong>与前面的区别：只要找到了一个能够满足要求的进程就把它满足。</strong></p>
</li>
</ul>
</li>
<li>
<p>从死锁恢复：进程回滚：每个disjoint cycle需要回滚一个。</p>
</li>
</ul>
<h2 id="08-Main-Memory">08 Main Memory</h2>
<ul>
<li>CPU可以直接访问的存储。L1 Cache - L2 Cache - Main Memory 存储层级结构。</li>
<li><strong>Base &amp; limit regsters:</strong> Base register 存储地址空间的起始地址；limit regster 存储地址空间的大小。这两个寄存器定义了逻辑地址空间。</li>
<li>Binding：编译时刻，装入时刻，执行时刻</li>
<li>前两个方法：逻辑地址和物理地址一样</li>
<li>Logical address和physical address在compile和load的地址绑定阶段相同，在执行时是不同的。logical addr由CPU generate，physical addr是存储单元看到的addr。</li>
<li>**Memory-Management Unit（MMU）。**Maps virtual to physical address。动态重定位：logical address（虚拟地址） + relocation base regster得到物理地址。</li>
<li>**Dynamic Loading：动态装入。**在一个进程启动后，将一个可执行文件或库映射到进程内存空间。一般由program支持，也比较难实现。</li>
<li><strong>Dynamic Linking：动态链接。<strong>不对那些组成程序的目标文件进行链接，等到程序要</strong>运行时</strong>才进行链接，不需要library code出现在process内部，节省了运行时的main memory空间也节省了存储空间。需要os support。</li>
<li>Contiguous Memory Allocation连续内存分配：主存一般分成两个部分，os system with interrupt vector（low addr）和user processes（high addr）。每个process都有一个base regsiter（物理地址）和一个limit register（虚拟地址范围，其实就是地址空间的大小），MMU对虚拟地址进行动态映射。
<ul>
<li>地址保护：&gt;=base &amp;&amp; &lt; base + limit，则可以访问memory。</li>
</ul>
</li>
<li>Multiple-partition allocation：os保存已经分配的patition和free patition（hole）的信息，当一个进程arrive的时候，从hole分配一个足够大的memory给进程。
<ul>
<li>external fragmentation：有很多个比较小的不相邻的hole。可以通过compaction解决，但也不是所有的进程都可以随便移动，比如不是运行时binding的进程；它也会花很大的代价。</li>
<li>internal fragmentation：系统分配memory的时候一般会多分配一点。</li>
</ul>
</li>
<li>Paging: 逻辑地址空间可以不连续。physical memory的block称为frame，logical memory的block称为page。两个size相同。map page to frame有一个表，这个表就是page table。</li>
<li>page table实现：Page-table base register (PTBR) 指向page table，Page-table length register (PTLR) 表示page table的size。但如果每次访问memory都要去访问page table，其实相当于每次都要做两次memory access，这样代价很大。所以我们需要一个cache（<strong>TLB</strong>，translation look-aside buffers，快表）来存。如下图所示，page number输入到TLB会进行并行搜索frame number，如果TLB hit，直接得到f；如果miss还是去page table访问。TLB相比于内存访问的时间几乎忽略不计。计算Effective access time。</li>
<li>Some TLBs store <strong>address-space identifiers (ASIDs)</strong> in each TLB entry – uniquely identifies each process to provide address-space protection for that process</li>
<li>Valid-invalid bit - mem protection</li>
<li>共享页：
<ul>
<li>shared code：copy of a read only code；must <strong>appear in same location in the logical address space</strong> of all processes</li>
<li>private code &amp; data：Each process keeps a separate copy of the code and data；The pages for the private code and data can <strong>appear anywhere in the logical address space</strong></li>
</ul>
</li>
<li>page table结构
<ul>
<li>Page table太长了的时候，要给page table也分页，比如two level page table。</li>
<li>Hashed Page Table：page table有a chain of elements，在链表里面找</li>
<li>Inverted Page Table：整个系统只有一个page table。每个frame都有一个entry，对应virtual addr和process信息。（找pid，p，排在表的i，i就是frame number。原来是排在表的p，对应的f就是frame number）</li>
</ul>
</li>
<li>Swapping：进程可以被暂时的swap出memory到backing store。
<ul>
<li>roll-out, roll-in</li>
<li>System maintains a <strong>ready queue</strong> of ready-to-run processes which have memory images on disk</li>
<li>UNIX, LINUX, WINDOWS</li>
</ul>
</li>
<li>Segmentation: 从user的角度来看memory，即逻辑地址空间下。不一定是连续的。维护信息： &lt;segment number, offset&gt;。分段和分页是会同时存在的。段页式。
<ul>
<li>Segment table(limit, base); STBR; STLR; valid bit</li>
</ul>
</li>
<li><u>The Intel Pentium</u>
<ul>
<li>段页式。逻辑地址空间分成local和global两块；有logical address，linear address，global address。offset前面的部分叫selector，就是Segment+LDT/GDT+Protection。</li>
</ul>
</li>
<li>liunx global dir middle dir page table offset</li>
</ul>
<h2 id="09-Virtual-Memory">09 Virtual Memory</h2>
<ul>
<li>
<p>Virtual Memory: physical memory与user logical memory的分离。程序只需要部分在memory中，在没改变response time或者turnaround time的情况下，提高了CPU的使用率和吞吐量。logical address space可以比physical address space大得多；address space可以被不同进程共享；进程创建可以更高效。</p>
</li>
<li>
<p>实现方式：Demand paging或者Demand segmentation</p>
</li>
<li>
<p>其他好处：system libraries can be shared；shared memory is enabled；process creation can be speeded up（在用fork()进程创建的时候可以share pages，所以加速）</p>
</li>
<li>
<p>demand paging：只在需要的时候bring a page into main memory。需要的I/O和memory都更少，response更快，允许的user也更多。</p>
</li>
<li>
<p>Lazy swapper: 直到page需要的时候才把page swap到memory。</p>
</li>
<li>
<p>page table做一个valid bit，访问一个标记了invalid的page就产生一个page fault，对OS造成一个trap。标记成i的时候可能是在memory中但无效，也有可能是不在memory中，需要区分：</p>
<ul>
<li>就是invalid reference =&gt; abort程序</li>
<li>not in memory =&gt; bring to memory</li>
</ul>
</li>
<li>
<p>遇到page fault，如果只是不在memory：get empty frame and swap page into frame，reset tables，set validation bit = v，restart the instruction。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>a</mi><mi>g</mi><mi>e</mi><mtext> </mtext><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi><mtext> </mtext><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">Page\ fault\ rate = p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>m</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>y</mi><mtext> </mtext><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mspace linebreak="newline"></mspace><mo>+</mo><mi>p</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mtext> </mtext><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi><mtext> </mtext><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo>+</mo><mi>s</mi><mi>w</mi><mi>a</mi><mi>p</mi><mtext> </mtext><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mtext> </mtext><mi>o</mi><mi>u</mi><mi>t</mi><mo>+</mo><mi>s</mi><mi>w</mi><mi>a</mi><mi>p</mi><mtext> </mtext><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mo>+</mo><mi>r</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mtext> </mtext><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EAT = (1 - p) * memory\ access \\ + p * (page\ fault\ overhead + swap\ page\ out + swap\ page\ in + restart\ overhead)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">ory</span><span class="mspace"> </span><span class="mord mathnormal">a</span><span class="mord mathnormal">ccess</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">+</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal">in</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">res</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><u>回到原来的程序执行状态：预先试图access，page fault会发生在什么都没修改的时候；或者用temporary register。</u></p>
</li>
<li>
<p>virtual memory允许了其他进程创建时候的好处：copy on write，memory-mapped files</p>
</li>
<li>
<p>copy on write COW：允许父子进程一开始的时候共享一样的page，copy的是page table而不是page本身。只有当其中一个process修改了page的时候，才真正copy出来。read only的时候一直用share的方式。</p>
<ul>
<li>加速了进程创建的过程。free page是从一个zeroed-out page池分配的。</li>
</ul>
</li>
<li>
<p>page replacement：如果没有free frame的话，就要进行page replacement。找到memory里一个没有在使用的page并把它换出去。我们希望有一种算法，使得page fault数量最小。</p>
<ul>
<li>
<p>用dirty bit来减少page transfer，只有修改过的page才写到disk。page replacement完成了logical和physical memory的分离，因为large virtual memory可以被一个小一些的physical memory提供。</p>
</li>
<li>
<p>找到一个free frame：</p>
<ul>
<li>有free frame，直接用</li>
<li>没有free frame，用page replacement algorithm选一个替换掉</li>
<li>把它写到secondary storage，改变page和frame table</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Page replacement algorithm</p>
<ul>
<li><u>number of page fault是不会到0的，启动的时候就会产生一部分page fault。</u></li>
<li>FIFO first in first out：<u>FIFO算法在某些情况下，frame增加page fault反而更多，这不是我们所期望的。</u><strong>Belady’s Anomaly</strong></li>
<li>Optimal Algorithm：把之后最不会被用到的page替换掉（平手则退化到FIFO）。这当然是最优的，但是我们没法预测哪个是最不会被用到的。</li>
<li>LRU：合理的假设：最近最少用到的，在near future也不太可能用的到，把它换掉。
<ul>
<li>counter implementation：每次访问把时间copy到counter；需要搜索哪个对应的时间是最早的。</li>
<li>stack implementation：当有一个page被refer就移动到栈顶，栈底被选择替换。需要移动很多链表元素，但不需要搜索。</li>
<li>所以match的多的话应该选前者（后者要移动元素），经常有fault的话选后者。</li>
</ul>
</li>
<li>LRU近似算法：没必要用counter记录下整个时间，为了简化，可以只用一两个bit。
<ul>
<li>reference bit：每一页关联一个bit，init = 0，referenced，set to 1。把bit=0的换掉（如果存在）</li>
<li>second chance，clock replacement：如果clock order下要被替换的页面refer bit=1，就set为0，并尝试替换下一个页面。circular queue。</li>
</ul>
</li>
<li>counting算法：用一个counter记录被reference的次数
<ul>
<li>LFU Algorithm：用的最少的以后用的也最少，所以换掉</li>
<li>MFU Algorithm：用的最少的肯定也是最新的，以后应该会被用到</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Allocation of Frames：每个process都需要一定的minimum number of frames。两种主要的分配方式：fixed allocation，priority allocation。fixed分配有equal的，也有根据进程size按比例proportional的。priority分配是按照priority number按比例分配。</p>
</li>
<li>
<p>如果有page fault，找替换的时候有两种方式：替换自己的frame；替换一个比较low priority的frame。</p>
<ul>
<li>global replacement：可以选择别的process的frame替换。更常用。缺点：page fault rate很难预测，无法控制自己的page fault rate。</li>
<li>local replacement：只能选择process自己的frame替换。缺点：free frame很难利用，容易造成low throughput。</li>
</ul>
</li>
<li>
<p>Thrashing（颠簸）：某个process忙于swapping pages in and out的现象。</p>
<ul>
<li>如果有个进程pages不够，page fault rate很高，就会导致Thrashing，进而造成CPU利用率很低，进程queue在paging device那边所以ready queue变空，OS/user就会觉得process可以更多（提高multiprogramming的degree），加更多的process，造成恶性循环。</li>
<li>demand paging：基于locality model，在一段时间里访问这一块pages，下一段时间访问另一些pages……Process migrates from one locality to another。<u>locality overlap</u>
<ul>
<li>如果size of locality &gt; total memory size，就会发生thrashing</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Working-set model</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>：working set window: 一个固定的page reference次数</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>S</mi><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">WSS_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：working set size of Process <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。最近<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>访问过的page数目。
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>太小则没办法涵盖一个locality，太大了会涵盖好几个</li>
</ul>
</li>
<li>怎么尽量避免Thrashing：尽量不让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mi mathvariant="normal">Σ</mi><mi>W</mi><mi>S</mi><msub><mi>S</mi><mi>i</mi></msub><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">D = \Sigma WSS_i &gt; m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>是所有进程的demand frames。如果出现这种情况，suspend one of the processes。</li>
</ul>
</li>
<li>
<p><strong>Page-Fault Frequency Scheme</strong>：每个进程设定一个可接受的page fault rate，如果太低了可以拿出一些frame，太高了就给一些frame。</p>
</li>
<li>
<p>Memory-Mapped Files：allows file I/O to be treated as routine memory access by <strong>mapping</strong> a disk block to a page in memory</p>
</li>
<li>
<p>Buddy system: Allocates memory from fixed-size segment consisting of physically-contiguous pages；Memory allocated using <strong>power-of-2 allocator</strong></p>
</li>
<li>
<p>slab one or more physically contiguous pages</p>
</li>
</ul>
<h2 id="10-FS-interface">10 FS interface</h2>
<p>文件目录的结构和表示，定义</p>
<ul>
<li>file：连续的逻辑地址空间；一段数据的sequence</li>
<li>文件信息保存在directory structure，在disk保存</li>
<li>open()：返回指向一个open-file table entry的指针</li>
<li>open file需要：file pointer（上次读写的位置），file open count，disk location of the file，access rights</li>
<li>open file lock：mandatory（强制的），advisory（只是提醒有问题）</li>
<li>MS-DOS，MAC-OS-X：每个file记录creator；UNIX-Magic number</li>
<li>文件access方式：sequential，dirent（random），index</li>
<li>文件目录结构：A collection of nodes containing (management) information about all files。都在disk上。</li>
<li>two-level directory，tree-structured</li>
<li>rm（delete file），mkdir（新建文件夹）</li>
<li>efficient，naming，grouping</li>
<li>acyclic-graph directories：可以有不一样的名字。
<ul>
<li>general graph directory：允不允许有环？有环的问题：repeat search，file deletion。怎么保证没有环？link只能指向文件不能到子文件夹，garbage collect，cycle detection</li>
</ul>
</li>
<li>mount：A file system must be <strong>mounted</strong> before it can be accessed。An un-mounted file system is mounted at a <strong>mount point</strong>。mount /dev/dsk /users</li>
<li>文件共享：protection scheme；On distributed systems, files may be shared across a network；nNetwork File System (NFS) is a common distributed file-sharing method
<ul>
<li>remote file system：client sever模型。NFS-UNIX, CIFS-WIN.</li>
<li><strong>Consistency semantics</strong> ：specify how multiple users are to access a shared file simultaneously。AFS-Andrew，UFS-Unix。lAFS has session semantics，Writes only visible to sessions starting after the file is closed</li>
</ul>
</li>
</ul>
<h2 id="11-FS-implementation">11 FS implementation</h2>
<p>文件系统实现，分配方式，题目</p>
<ul>
<li>文件结构：逻辑存储单元。File control block - inode in UFS，master file table entry in NTFS</li>
<li>层次文件系统</li>
<li>实现FS：Disk structure，in memory structure</li>
<li><u>文件目录实现：linear list，hash table（fixed size - chained overflow）</u></li>
<li>分配方式：contiguous，linked，indexed
<ul>
<li>连续分配：有点：简单，只需要开始位置和长度；支持random access；缺点：浪费空间，file cannot grow。map：Q+start addr，R=offset</li>
<li>extent-based：linked allocation。disk block的链表。简单，只需要起始地址；没有浪费空间；但不支持random access，reliability很差。map：Qth block，offset = R+1。FAT - MS-DOS, OS/2</li>
<li>indexed：需要index table，支持random access，没有浪费空间但是需要index block的overhead。Q=displacement into index table，R=offset。可以多层index。</li>
</ul>
</li>
<li>free space管理：bit vector，为1则free。bit map需要空间，但是容易get连续file；linked list很难get连续空间，但是可以work（FAT），没有浪费空间；grouping：存储开始的free block的地址，最后一个block存储下面n个free block的地址。counting：第一个free block的addr和连续free block的数量。</li>
<li>保护：指向free list的指针，bit map（存在disk上，memory和disk要一致，所以先把disk的set 1，再deallocate，最后把memory的set 1）</li>
<li>page cache：caches pages rather than disk blocks。memory-mapped IO使用，routine IO用buffer cache。unified buffer cache：cache both</li>
<li>recovery，log structure，NFS</li>
</ul>
<h2 id="12-Mass-Storage-System">12 Mass Storage System</h2>
<p>寻道算法，不同调度方法，交换分区，RAID</p>
<ul>
<li>disk结构：track：一个盘片上的一个圈；platter：盘片；sector：一个盘片上的一个扇形区域；track sector：一个track上的一个弧；cluster：连在一起的几个track sector；arm, cylinder</li>
<li>seek time：把arm移动到position disk head的时间</li>
<li>rotational delay：block再head下面rotate的时间</li>
<li>transfer time：move data from/to disk surface的时间</li>
<li>disk scheduling：
<ul>
<li>FCFS</li>
<li>SSTF(shortest seek time first)，可能造成饥饿。common。</li>
<li>SCAN（elevator）朝一个end移动，再反方向end移动</li>
<li>C-SCAN：到一个end之后，立刻到另一个end，继续SCAN</li>
<li>C-LOOK：不移动到end，只到request的end</li>
</ul>
</li>
<li>SCAN和CSCAN在disk load比较heavy的系统表现更好。</li>
<li>swap space management：Virtual memory uses disk space as an extension of main memory.
<ul>
<li>Kernel uses <em>swap maps</em> to track swap-space use.</li>
</ul>
</li>
<li>RAID：multiple disk drives provides <strong>reliability</strong> via <strong>redundancy</strong>
<ul>
<li>RAID1：多一组一样的disk</li>
<li>RAID2：memory-style Hamming code parity</li>
<li>RAID3：bit interleaved parity</li>
<li>RAID4：block interleaved parity</li>
<li>RAID5：block interleaved distributed parity</li>
<li>RAID6：P+Q redundancy</li>
</ul>
</li>
<li>RAID 0+1: stripe then mirror；1+0：mirror then stripe</li>
</ul>
<h2 id="13-IO-system">13 IO system</h2>
<p>DMA</p>
<ul>
<li>IO硬件：port，bus，controller……</li>
<li>port reg：data in，data out，status，control</li>
<li>polling流程</li>
<li>interrupt流程</li>
<li><strong>DMA direct memory access流程</strong></li>
</ul>
<h2 id="复习课">复习课</h2>
<ul>
<li>chap1
<ul>
<li>操作系统定义；os定义；interrupt概念；interrupt分类（其中有一个system call），同步异步IO</li>
<li>device status table；存储层次结构；cache和一致性协议；</li>
<li>multiprogramming和multitasking；user-mode和kernel-mode</li>
</ul>
</li>
<li>chap2
<ul>
<li>os服务：资源分配</li>
</ul>
</li>
<li>chap3
<ul>
<li>进程状态，状态transition diagram，waiting state called blocked state</li>
<li>PCB contents，process scheduling queue，context switch，producer-consumer</li>
<li>IPC（Interprocess Communication）model</li>
</ul>
</li>
<li>chap4
<ul>
<li>线程概念，user/kernel thread，multi-threading model（many to one，two level……）</li>
<li>thread specific data structure</li>
</ul>
</li>
<li>chap5
<ul>
<li>CPU调度指标criteria：utilization，throughput，……time*3</li>
<li>调度算法；SJF not practical</li>
</ul>
</li>
<li>chap6（今年难度中等）
<ul>
<li>解决CS problem的三个要求；抢占式/非抢占式kernel；同步hardware</li>
<li>semaphore - counting semaphore（P是wait，V是signal）</li>
<li>producer-consumer（bounded buffer problem）</li>
<li>readers-writers problem</li>
</ul>
</li>
<li>chap7
<ul>
<li>死锁的四个条件；死锁预防/避免；banker algorithm</li>
</ul>
</li>
<li>chap8
<ul>
<li>binding time，逻辑/物理地址，swapping，动态存储分配（FF/BF/WF）</li>
<li>external/internal fragmentation，内部外部区分</li>
<li>paging，paging table，TLB，层次page table，inverted page table，注意计算</li>
<li>EAT，Segmentation：segment table</li>
</ul>
</li>
<li>chap9
<ul>
<li>VM的概念，demand paging，page fault，EAT</li>
<li>Page replacement algorithm - LRU，OPT，NRU，CLOCK，MFU</li>
<li>thrashing；working-set model</li>
</ul>
</li>
<li>chap10 &amp; 11
<ul>
<li>file system，file operation，open file table，access method</li>
<li>directory structure，tree structure，绝对相对路径</li>
<li>FCB，虚拟FS，file分配方法：连续/linked/FAT/indexed，extents，Unix file allocation</li>
<li>Free space mgmt，log structure FS；linux是混合式的</li>
<li>给一个文件的逻辑地址 换算成物理地址 涉及磁盘块的访问（不同分配方式不一样）</li>
</ul>
</li>
<li>chap12
<ul>
<li>time to access a disk  block</li>
<li>disk scheduling algorithm</li>
<li>RAID concept</li>
</ul>
</li>
<li>chap13
<ul>
<li>IO操作访问的device，memory mapped IO，blocking/non blocking IO，device status table</li>
<li>polling，interrupt，DMA</li>
<li>caching，buffering，spooling（概念了解一下就可以）</li>
<li>io request的life cycle</li>
</ul>
</li>
<li>OS lab
<ul>
<li>ls，cp，ln，mv，echo，gcc，find，grep……以及basic bash/shell command</li>
<li><strong>how to write a kernel module</strong></li>
<li><strong>lab project guide要看一下</strong></li>
<li>building a kernel；boot process</li>
<li>PCB（task_struct field）</li>
<li>process state</li>
<li>create child processes（fork）</li>
<li>进程调度：了解一下</li>
<li>system call：processing，调用，return from system call，实验内容看一下</li>
<li>kernel的DS：不考</li>
<li>中断：中断向量……实现……跳过了</li>
<li>kernel memory，addr space是怎么管理的，了解一下，VMA，MM
<ul>
<li>page fault处理的流程，buddy算法，slab分配（大小不一的数据结构统一管理）</li>
</ul>
</li>
<li>linux FS：linux FCB（混合式的存储结构）：关注VFS，内存里有与FCB对应的VFS，为了得到inode，如果VFS已经mount，要从内存访问相应的磁盘里的FCB，然后去找文件；open，read，实验三guide</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">bebinca</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://bebinca.github.io/2021/01/19/os%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://bebinca.github.io/2021/01/19/os%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Course/">Course</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%A4%8D%E4%B9%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2021/10/08/yuiq3Oo8QIDLEpc.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机视觉复习</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/13/AOR8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cover/AOR8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">AOR8 博弈</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/01/11/AOR7/" title="AOR7 Online问题"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2021/10/08/yuiq3Oo8QIDLEpc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-11</div><div class="title">AOR7 Online问题</div></div></a></div><div><a href="/2021/01/13/AOR8/" title="AOR8 博弈"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cover/AOR8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-13</div><div class="title">AOR8 博弈</div></div></a></div><div><a href="/2020/10/30/AOR2/" title="AOR2 原始对偶方法、整数规划"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cover/AOR2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-30</div><div class="title">AOR2 原始对偶方法、整数规划</div></div></a></div><div><a href="/2020/11/15/AOR3/" title="AOR3 近似算法"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2021/10/08/yuiq3Oo8QIDLEpc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-15</div><div class="title">AOR3 近似算法</div></div></a></div><div><a href="/2020/10/14/AOR1/" title="AOR1 线性规划、单纯形法、对偶单纯形法"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2021/10/08/yuiq3Oo8QIDLEpc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">AOR1 线性规划、单纯形法、对偶单纯形法</div></div></a></div><div><a href="/2020/12/01/AOR4/" title="AOR4 贪心算法、独立系统、拟阵"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cover/AOR4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">AOR4 贪心算法、独立系统、拟阵</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bebinca</div><div class="author-info__description">:)</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bebinca"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">OS复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Introduction"><span class="toc-text">01 Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-os-structures"><span class="toc-text">02 os structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-Processes"><span class="toc-text">03 Processes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-Threads"><span class="toc-text">04 Threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-CPU-Scheduling"><span class="toc-text">05 CPU Scheduling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-Process-Synchronization"><span class="toc-text">06 Process Synchronization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-Deadlocks"><span class="toc-text">07 Deadlocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-Main-Memory"><span class="toc-text">08 Main Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-Virtual-Memory"><span class="toc-text">09 Virtual Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-FS-interface"><span class="toc-text">10 FS interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-FS-implementation"><span class="toc-text">11 FS implementation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Mass-Storage-System"><span class="toc-text">12 Mass Storage System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-IO-system"><span class="toc-text">13 IO system</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%E8%AF%BE"><span class="toc-text">复习课</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%A4%8D%E4%B9%A0/" title="计算机视觉复习">计算机视觉复习</a><time datetime="2021-01-20T17:10:00.000Z" title="Created 2021-01-21 01:10:00">2021-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/19/os%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="OS期末复习">OS期末复习</a><time datetime="2021-01-19T02:11:00.000Z" title="Created 2021-01-19 10:11:00">2021-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/13/AOR8/" title="AOR8 博弈"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cover/AOR8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AOR8 博弈"/></a><div class="content"><a class="title" href="/2021/01/13/AOR8/" title="AOR8 博弈">AOR8 博弈</a><time datetime="2021-01-13T02:11:00.000Z" title="Created 2021-01-13 10:11:00">2021-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/11/AOR7/" title="AOR7 Online问题">AOR7 Online问题</a><time datetime="2021-01-11T02:11:00.000Z" title="Created 2021-01-11 10:11:00">2021-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/10/AOR6/" title="AOR6 装箱问题"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/cover/AOR6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AOR6 装箱问题"/></a><div class="content"><a class="title" href="/2021/01/10/AOR6/" title="AOR6 装箱问题">AOR6 装箱问题</a><time datetime="2021-01-10T14:11:00.000Z" title="Created 2021-01-10 22:11:00">2021-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By bebinca</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'qyCo4hwX3isjMcJ5Dqo5rxcJ-gzGzoHsz',
      appKey: 'SEtM4mYef8hhABdsD4F7XRhB',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="1" zIndex="-1" count="170" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>